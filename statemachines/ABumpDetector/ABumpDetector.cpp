//****************************************************************************
// Model: AccBumpDetector.qm
// File:  ABumpDetector/ABumpDetector.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${SigProc::ABumpDetector::ABumpDetector.cpp} ...............................
#include "ABumpDetector.h"
#include "CircularBuffer.h"
#include "app_ao_config.h"
#include "active_log.h"
#include "AO_IKS01A1.h"
#include <math.h>

using namespace IKS01A1;
using namespace StdDataStruct;
using namespace StdEvents;
using namespace QP;

namespace SigProc {


#if ((QP_VERSION < 580) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpcpp version 5.8.0 or higher required
#endif

//${SigProc::BumpDetector} ...................................................
//${SigProc::BumpDetector::BumpDetector} .....................................
BumpDetector::BumpDetector(
    uint32_t interval,
    CircularBuffer<SensorAxesBufferElement> * buffer,
    double threshold)
  :AO(ABUMP_DET_TIMEOUT_SIG
     ,(QStateHandler)&initial
     ,"Bump Detector")
   , m_collectionInterval(interval)
   , m_buffer(buffer)
   , m_bumpThreshold(threshold)
{}

//${SigProc::BumpDetector::ProcessData} ......................................
void BumpDetector::ProcessData() {
    CircularBufferRange range = m_buffer->getRange(HAL_GetTick() - 100, HAL_GetTick());
    if (range.end < 0 || range.start < 0 || range.end - range.start < 4) {
        // InSufficient data
        return;
    }
    SensorAxes_t prevAxes = m_buffer->get(range.start).axes;
    double maxDiff = 0;
    uint32_t bumpIndex = -1;
    for(int i = range.start + 1; i <= range.end; i++) {
        SensorAxes_t currAxes = m_buffer->get(i).axes;
        double diff = sqrt((currAxes.AXIS_X - prevAxes.AXIS_X)^2 + (currAxes.AXIS_Y - prevAxes.AXIS_Y)^2 + (currAxes.AXIS_Z - prevAxes.AXIS_Z)^2);
        if (diff > maxDiff) {
            maxDiff = diff;
            bumpIndex = i;
        }
        prevAxes = currAxes;
    }
    if (maxDiff  > m_bumpThreshold && m_showBumps) {
        uint32_t bumpTimestamp = m_buffer->get(bumpIndex).timestamp;
        PRINT("Found Bump with magnitude %d at time %d\r\n", ((int)maxDiff), bumpTimestamp);
        Publish(new ABumpEvent(maxDiff, bumpTimestamp, m_nextSequence++));
    }

}
//${SigProc::BumpDetector::SM} ...............................................
QP::QState BumpDetector::initial(BumpDetector * const me, QP::QEvt const * const e) {
    // ${SigProc::BumpDetector::SM::initial}
    me->subscribe(ABUMP_DET_START_REQ_SIG);
    me->subscribe(ABUMP_DET_START_CFM_SIG);
    me->subscribe(ABUMP_DET_STOP_REQ_SIG);
    me->subscribe(ABUMP_DET_STOP_CFM_SIG);
    me->subscribe(ABUMP_DET_FAILED_SIG);
    me->subscribe(ABUMP_DET_TIMEOUT_SIG);
    return Q_TRAN(&Stopped);
}
//${SigProc::BumpDetector::SM::Root} .........................................
QP::QState BumpDetector::Root(BumpDetector * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&top);
            break;
        }
    }
    return status_;
}
//${SigProc::BumpDetector::SM::Root::Stopped} ................................
QP::QState BumpDetector::Stopped(BumpDetector * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SigProc::BumpDetector::SM::Root::Stopped::ABUMP_DET_START_REQ}
        case ABUMP_DET_START_REQ_SIG: {
            me->PublishConfirmation(
                EVT_CAST(*e),
                ABUMP_DET_START_CFM_SIG);
            status_ = Q_TRAN(&Started);
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${SigProc::BumpDetector::SM::Root::Started} ................................
QP::QState BumpDetector::Started(BumpDetector * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SigProc::BumpDetector::SM::Root::Started::initial}
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&CollectingData);
            break;
        }
        // ${SigProc::BumpDetector::SM::Root::Started::ABUMP_DET_STOP_REQ}
        case ABUMP_DET_STOP_REQ_SIG: {
            me->PublishConfirmation(
                EVT_CAST(*e),
                ABUMP_DET_STOP_CFM_SIG);
            status_ = Q_TRAN(&Stopped);
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${SigProc::BumpDetector::SM::Root::Started::CollectingData} ................
QP::QState BumpDetector::CollectingData(BumpDetector * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SigProc::BumpDetector::SM::Root::Started::CollectingData}
        case Q_ENTRY_SIG: {
            me->m_timer.armX(
                me->m_collectionInterval,
                me->m_collectionInterval);
            status_ = Q_HANDLED();
            break;
        }
        // ${SigProc::BumpDetector::SM::Root::Started::CollectingData}
        case Q_EXIT_SIG: {
            me->m_timer.disarm();
            status_ = Q_HANDLED();
            break;
        }
        // ${SigProc::BumpDetector::SM::Root::Started::CollectingData::ABUMP_DET_FAILED}
        case ABUMP_DET_FAILED_SIG: {
            status_ = Q_TRAN(&Failed);
            break;
        }
        // ${SigProc::BumpDetector::SM::Root::Started::CollectingData::ABUMP_DET_TIMEOUT}
        case ABUMP_DET_TIMEOUT_SIG: {
            me->ProcessData();
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Started);
            break;
        }
    }
    return status_;
}
//${SigProc::BumpDetector::SM::Root::Started::Failed} ........................
QP::QState BumpDetector::Failed(BumpDetector * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&Started);
            break;
        }
    }
    return status_;
}

} // namespace SigProc
