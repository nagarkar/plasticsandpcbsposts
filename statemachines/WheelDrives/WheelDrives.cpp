//****************************************************************************
// Model: WheelDrives.qm
// File:  WheelDrives/WheelDrives.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${WheelDrives::WheelDrives::WheelDrives.cpp} ...............................
#include "WheelDrives.h"
#include <math.h>

using namespace std;
using namespace QP;
using namespace StdEvents;

namespace WheelDrives {


#if ((QP_VERSION < 580) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpcpp version 5.8.0 or higher required
#endif

//${WheelDrives::Wheel} ......................................................
//${WheelDrives::Wheel::Wheel} ...............................................
Wheel::Wheel(uint8_t wheelId, QP::QActive * owner)
  : ASM(WHEEL_DRIVES_WHEEL_TIMEOUT_SIG
      ,(QStateHandler)&initial
      , owner
      , "Wheel")
    , m_wheelId(wheelId)
{}

//${WheelDrives::Wheel::SM} ..................................................
QP::QState Wheel::initial(Wheel * const me, QP::QEvt const * const e) {
    // ${WheelDrives::Wheel::SM::initial}
    return Q_TRAN(&Stopped);
}
//${WheelDrives::Wheel::SM::Root} ............................................
QP::QState Wheel::Root(Wheel * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${WheelDrives::Wheel::SM::Root}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${WheelDrives::Wheel::SM::Root}
        case Q_EXIT_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&top);
            break;
        }
    }
    return status_;
}
//${WheelDrives::Wheel::SM::Root::Started} ...................................
QP::QState Wheel::Started(Wheel * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${WheelDrives::Wheel::SM::Root::Started}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            me->PublishConfirmation(
                EVT_CAST(*e),
                WHEEL_DRIVES_WHEEL_START_CFM_SIG);
            status_ = Q_HANDLED();
            break;
        }
        // ${WheelDrives::Wheel::SM::Root::Started}
        case Q_EXIT_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${WheelDrives::Wheel::SM::Root::Started::initial}
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Running);
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${WheelDrives::Wheel::SM::Root::Started::Failed} ...........................
QP::QState Wheel::Failed(Wheel * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${WheelDrives::Wheel::SM::Root::Started::Failed}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Started);
            break;
        }
    }
    return status_;
}
//${WheelDrives::Wheel::SM::Root::Started::Running} ..........................
QP::QState Wheel::Running(Wheel * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${WheelDrives::Wheel::SM::Root::Started::Running}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${WheelDrives::Wheel::SM::Root::Started::Running::WHEEL_DRIVES_WHEEL_MOVE_REQ}
        case WHEEL_DRIVES_WHEEL_MOVE_REQ_SIG: {
            LOG_EVENT(e);
            const WheelMoveRequestEvt * evt = WHEEL_MOVE_EVT_CAST(e);

            me->PublishConfirmation(
                EVT_CAST(*e),
                WHEEL_DRIVES_WHEEL_MOVE_CFM_SIG);

            double newVelocity = evt->m_goal.get()->xVelocity;
            PRINT("Moving wheel %d with velocity %f\r\n", me->m_wheelId, newVelocity);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Started);
            break;
        }
    }
    return status_;
}
//${WheelDrives::Wheel::SM::Root::Stopped} ...................................
QP::QState Wheel::Stopped(Wheel * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${WheelDrives::Wheel::SM::Root::Stopped::WHEEL_DRIVES_WHEEL_START_REQ}
        case WHEEL_DRIVES_WHEEL_START_REQ_SIG: {
            me->PublishConfirmation(
                EVT_CAST(*e),
                WHEEL_DRIVES_WHEEL_START_CFM_SIG);
            status_ = Q_TRAN(&Started);
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${WheelDrives::DiffDrive} ..................................................
//${WheelDrives::DiffDrive::DiffDrive} .......................................
DiffDrive::DiffDrive()
  : AO(WHEEL_DRIVES_DD_TIMEOUT_SIG
        , (QStateHandler)&initial
        , "Diff Drive")
    , m_leftWheel(DIFF_DRIVE_LEFT_WHEEL, this)
    , m_rightWheel(DIFF_DRIVE_RIGHT_WHEEL, this)
{}

//${WheelDrives::DiffDrive::PublishWheelVelocitiesFor} .......................
uint32_t DiffDrive::PublishWheelVelocitiesFor(std::shared_ptr<Goal> goalPtr) {
    Goal* goal = goalPtr.get();
    switch(goal->type) {
        case TWO_D_VELOCITY: {
            TwoDVelocityGoal *twoDGoal = TWO_D_VELOCITY_GOAL(goal);
            PublishLeftAndRightWheelVelocities(*twoDGoal);
            return 1;
        }
        default: {
            return -1;
            break;
        }
    }

}
//${WheelDrives::DiffDrive::PublishLeftAndRightWheelVelociti~} ...............
uint32_t DiffDrive::PublishLeftAndRightWheelVelocities(TwoDVelocityGoal & twoDGoal) {
    double  R = 1, L = 1,
            phiCurrent = 0,
            u1 = 0, u2 = 0,
            phiDesired = 0, omega = 0, v = 0,
            vR = 0, vL = 0;
    u1 = twoDGoal.yVelocity;
    u2 = twoDGoal.xVelocity;
    phiDesired = atan2(u2,u1);
    omega = PID(phiDesired - phiCurrent);
    v = sqrt(u1*u1 + u2*u2);
    vR = v/R + omega*L/(2*R);
    vL = vR - 2*(omega*L/(2*R));
    std::shared_ptr<OneDVelocityGoal> leftGoal =
        std::make_shared<OneDVelocityGoal>();
    leftGoal.get()->xVelocity = vL;
    m_leftWheel.dispatch(new WheelMoveRequestEvt(m_nextSequence++, leftGoal));

    std::shared_ptr<OneDVelocityGoal> rightGoal =
        std::make_shared<OneDVelocityGoal>();
    rightGoal.get()->xVelocity = vR;
    m_rightWheel.dispatch(new WheelMoveRequestEvt(m_nextSequence++, rightGoal));
    return 1;
}
//${WheelDrives::DiffDrive::SM} ..............................................
QP::QState DiffDrive::initial(DiffDrive * const me, QP::QEvt const * const e) {
    // ${WheelDrives::DiffDrive::SM::initial}
    me->subscribe(WHEEL_DRIVES_WHEEL_TIMEOUT_SIG);
    me->subscribe(WHEEL_DRIVES_WHEEL_START_REQ_SIG);
    me->subscribe(WHEEL_DRIVES_WHEEL_START_CFM_SIG);
    me->subscribe(WHEEL_DRIVES_WHEEL_STOP_REQ_SIG);
    me->subscribe(WHEEL_DRIVES_WHEEL_STOP_CFM_SIG);
    me->subscribe(WHEEL_DRIVES_WHEEL_MOVE_REQ_SIG);
    me->subscribe(WHEEL_DRIVES_WHEEL_MOVE_CFM_SIG);


    me->subscribe(WHEEL_DRIVES_DD_TIMEOUT_SIG);
    me->subscribe(WHEEL_DRIVES_DD_START_REQ_SIG);
    me->subscribe(WHEEL_DRIVES_DD_START_CFM_SIG);
    me->subscribe(WHEEL_DRIVES_DD_STOP_REQ_SIG);
    me->subscribe(WHEEL_DRIVES_DD_STOP_CFM_SIG);
    me->subscribe(WHEEL_DRIVES_DD_FAILED_SIG);
    me->subscribe(WHEEL_DRIVES_DD_HEADING_CFM_SIG);
    me->subscribe(WHEEL_DRIVES_DD_HEADING_SIG);

    return Q_TRAN(&Stopped);
}
//${WheelDrives::DiffDrive::SM::Root} ........................................
QP::QState DiffDrive::Root(DiffDrive * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${WheelDrives::DiffDrive::SM::Root}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            me->m_leftWheel.Init();
            me->m_rightWheel.Init();
            status_ = Q_HANDLED();
            break;
        }
        // ${WheelDrives::DiffDrive::SM::Root::WHEEL_DRIVES_WHEEL_MOVE_REQ,WHEE~}
        case WHEEL_DRIVES_WHEEL_MOVE_REQ_SIG: // intentionally fall through
        case WHEEL_DRIVES_WHEEL_TIMEOUT_SIG: {
            LOG_EVENT(e);
            // TODO: Dispatch event to correct wheel
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&top);
            break;
        }
    }
    return status_;
}
//${WheelDrives::DiffDrive::SM::Root::Stopped} ...............................
QP::QState DiffDrive::Stopped(DiffDrive * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${WheelDrives::DiffDrive::SM::Root::Stopped}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${WheelDrives::DiffDrive::SM::Root::Stopped::WHEEL_DRIVES_DD_START_REQ}
        case WHEEL_DRIVES_DD_START_REQ_SIG: {
            status_ = Q_TRAN(&Active);
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${WheelDrives::DiffDrive::SM::Root::Active} ................................
QP::QState DiffDrive::Active(DiffDrive * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${WheelDrives::DiffDrive::SM::Root::Active::initial}
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Starting);
            break;
        }
        // ${WheelDrives::DiffDrive::SM::Root::Active::WHEEL_DRIVES_DD_STOP_REQ}
        case WHEEL_DRIVES_DD_STOP_REQ_SIG: {
            me->PublishConfirmation(
                EVT_CAST(*e),
                WHEEL_DRIVES_DD_STOP_CFM_SIG);
            status_ = Q_TRAN(&Stopped);
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${WheelDrives::DiffDrive::SM::Root::Active::Failed} ........................
QP::QState DiffDrive::Failed(DiffDrive * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${WheelDrives::DiffDrive::SM::Root::Active::Failed}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${WheelDrives::DiffDrive::SM::Root::Active::Failed::WHEEL_DRIVES_DD_HEADING}
        case WHEEL_DRIVES_DD_HEADING_SIG: {
            me->PublishConfirmationWithInvalidState(
                EVT_CAST(*e),
                WHEEL_DRIVES_DD_START_CFM_SIG);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Active);
            break;
        }
    }
    return status_;
}
//${WheelDrives::DiffDrive::SM::Root::Active::Starting} ......................
QP::QState DiffDrive::Starting(DiffDrive * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${WheelDrives::DiffDrive::SM::Root::Active::Starting}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            me->m_leftWheel.dispatch(
                new Evt(WHEEL_DRIVES_WHEEL_START_REQ_SIG));
            me->m_rightWheel.dispatch(
                new Evt(WHEEL_DRIVES_WHEEL_START_REQ_SIG));
            me->m_timer.armX(10);
            status_ = Q_HANDLED();
            break;
        }
        // ${WheelDrives::DiffDrive::SM::Root::Active::Starting::WHEEL_DRIVES_DD_TIMEOUT}
        case WHEEL_DRIVES_DD_TIMEOUT_SIG: {
            LOG_EVENT(e);
            me->postLIFO(new Evt(WHEEL_DRIVES_DD_FAILED_SIG));
            status_ = Q_HANDLED();
            break;
        }
        // ${WheelDrives::DiffDrive::SM::Root::Active::Starting::WHEEL_DRIVES_WHEEL_START_CFM}
        case WHEEL_DRIVES_WHEEL_START_CFM_SIG: {
            uint8_t result = me->HandleCfm(
                ERROR_EVT_CAST(*e),
                2,    // Expected count
                WHEEL_DRIVES_DD_START_CFM_SIG,
                WHEEL_DRIVES_DD_FAILED_SIG);
            // ${WheelDrives::DiffDrive::SM::Root::Active::Starting::WHEEL_DRIVES_WHE~::[Allconfirmed]}
            if (result > 0) {
                status_ = Q_TRAN(&Started);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Active);
            break;
        }
    }
    return status_;
}
//${WheelDrives::DiffDrive::SM::Root::Active::Started} .......................
QP::QState DiffDrive::Started(DiffDrive * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${WheelDrives::DiffDrive::SM::Root::Active::Started}
        case Q_ENTRY_SIG: {
            me->PublishConfirmation(
                EVT_CAST(*e),
                WHEEL_DRIVES_DD_START_CFM_SIG);
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${WheelDrives::DiffDrive::SM::Root::Active::Started::WHEEL_DRIVES_DD_HEADING}
        case WHEEL_DRIVES_DD_HEADING_SIG: {
            me->PublishConfirmation(
                EVT_CAST(*e),
                WHEEL_DRIVES_DD_HEADING_CFM_SIG);

            const HeadingRequestEvt * const evt = HEADING_EVT_CAST(e);
            me->PublishWheelVelocitiesFor(evt->m_goal);

            //TODO: Send Failure if heading
            //is not acheivable.
            status_ = Q_HANDLED();
            break;
        }
        // ${WheelDrives::DiffDrive::SM::Root::Active::Started::WHEEL_DRIVES_DD_FAILED}
        case WHEEL_DRIVES_DD_FAILED_SIG: {
            status_ = Q_TRAN(&Failed);
            break;
        }
        default: {
            status_ = Q_SUPER(&Active);
            break;
        }
    }
    return status_;
}
//${WheelDrives::Bumper} .....................................................
//${WheelDrives::Bumper::Bumper} .............................................
Bumper::Bumper(uint16_t pin, enum_t position)
  : AO(WHEEL_DRIVES_BUMPER_TIMEOUT_SIG
        , (QStateHandler)initial, "Bumper")
    ,m_pin(pin)
    ,m_position(position)
{}

//${WheelDrives::Bumper::SM} .................................................
QP::QState Bumper::initial(Bumper * const me, QP::QEvt const * const e) {
    // ${WheelDrives::Bumper::SM::initial}
      me->subscribe(SYSTEM_PIN_SET_INTERRUPT_SIG);
      me->subscribe(SYSTEM_PIN_RESET_INTERRUPT_SIG);
    return Q_TRAN(&NotInitialized);
}
//${WheelDrives::Bumper::SM::Root} ...........................................
QP::QState Bumper::Root(Bumper * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&top);
            break;
        }
    }
    return status_;
}
//${WheelDrives::Bumper::SM::Root::Bumping} ..................................
QP::QState Bumper::Bumping(Bumper * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${WheelDrives::Bumper::SM::Root::Bumping}
        case Q_ENTRY_SIG: {
            Evt *evt = new BumpedEvt(me->m_nextSequence++, me->m_position);
            QF::PUBLISH(evt, me);
            status_ = Q_HANDLED();
            break;
        }
        // ${WheelDrives::Bumper::SM::Root::Bumping::SYSTEM_PIN_RESET_INTERRUPT}
        case SYSTEM_PIN_RESET_INTERRUPT_SIG: {
            status_ = Q_TRAN(&NotBumping);
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${WheelDrives::Bumper::SM::Root::NotBumping} ...............................
QP::QState Bumper::NotBumping(Bumper * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${WheelDrives::Bumper::SM::Root::NotBumping}
        case Q_ENTRY_SIG: {
            Evt *evt = new UnBumpedEvt(me->m_nextSequence++, me->m_position);
            QF::PUBLISH(evt, me);
            status_ = Q_HANDLED();
            break;
        }
        // ${WheelDrives::Bumper::SM::Root::NotBumping::SYSTEM_PIN_SET_INTERRUPT}
        case SYSTEM_PIN_SET_INTERRUPT_SIG: {
            status_ = Q_TRAN(&Bumping);
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${WheelDrives::Bumper::SM::Root::NotInitialized} ...........................
QP::QState Bumper::NotInitialized(Bumper * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${WheelDrives::Bumper::SM::Root::NotInitialized}
        case Q_ENTRY_SIG: {
            if(BSP_PIN_SET(m_pin)) {
              return Q_TRAN(&Bumping);
            } else {
              return Q_TRAN(&NotBumping);
            }
            status_ = Q_HANDLED();
            break;
        }
        // ${WheelDrives::Bumper::SM::Root::NotInitialized::SYSTEM_PIN_SET_INTERRUPT}
        case SYSTEM_PIN_SET_INTERRUPT_SIG: {
            status_ = Q_TRAN(&Bumping);
            break;
        }
        // ${WheelDrives::Bumper::SM::Root::NotInitialized::SYSTEM_PIN_RESET_INTERRUPT}
        case SYSTEM_PIN_RESET_INTERRUPT_SIG: {
            status_ = Q_TRAN(&NotBumping);
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${WheelDrives::FWNavSystem} ................................................
//${WheelDrives::FWNavSystem::SM} ............................................
QP::QState FWNavSystem::initial(FWNavSystem * const me, QP::QEvt const * const e) {
    // ${WheelDrives::FWNavSystem::SM::initial}
    return Q_TRAN(&Root);
}
//${WheelDrives::FWNavSystem::SM::Root} ......................................
QP::QState FWNavSystem::Root(FWNavSystem * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&top);
            break;
        }
    }
    return status_;
}
//${WheelDrives::FWNavSystem::SM::Root::Stopped} .............................
QP::QState FWNavSystem::Stopped(FWNavSystem * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${WheelDrives::FWNavSystem::SM::Root::Started} .............................
QP::QState FWNavSystem::Started(FWNavSystem * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${WheelDrives::FWNavSystem::SM::Root::Started::initial}
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&GTG);
            break;
        }
        // ${WheelDrives::FWNavSystem::SM::Root::Started::NAV_UNOBSTRUCTED_GOAL}
        case NAV_UNOBSTRUCTED_GOAL_SIG: {
            status_ = Q_TRAN(&GTG);
            break;
        }
        // ${WheelDrives::FWNavSystem::SM::Root::Started::NAV_OBST_DANGER_ZONE_IND}
        case NAV_OBST_DANGER_ZONE_IND_SIG: {
            status_ = Q_TRAN(&AvoidObst);
            break;
        }
        // ${WheelDrives::FWNavSystem::SM::Root::Started::NAV_OBST_CLOSE_IND}
        case NAV_OBST_CLOSE_IND_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${WheelDrives::FWNavSystem::SM::Root::Started::FollowWallC} ................
QP::QState FWNavSystem::FollowWallC(FWNavSystem * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&Started);
            break;
        }
    }
    return status_;
}
//${WheelDrives::FWNavSystem::SM::Root::Started::FollowWallCC} ...............
QP::QState FWNavSystem::FollowWallCC(FWNavSystem * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&Started);
            break;
        }
    }
    return status_;
}
//${WheelDrives::FWNavSystem::SM::Root::Started::GTG} ........................
QP::QState FWNavSystem::GTG(FWNavSystem * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&Started);
            break;
        }
    }
    return status_;
}
//${WheelDrives::FWNavSystem::SM::Root::Started::AvoidObst} ..................
QP::QState FWNavSystem::AvoidObst(FWNavSystem * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&Started);
            break;
        }
    }
    return status_;
}
//${WheelDrives::BumpedEvt} ..................................................
//${WheelDrives::BumpedEvt::BumpedEvt} .......................................
BumpedEvt::BumpedEvt(uint16_t seq, enum_t position)
  :Evt(WHEEL_DRIVES_BUMPER_BUMPED_SIG, seq), m_position(position)
{}

//${WheelDrives::BumpedEvt::BumpedEvt} .......................................
BumpedEvt::BumpedEvt(
    QSignal timeoutSignal,
    uint16_t seq,
    enum_t position)
  :Evt(timeoutSignal, seq), m_position(position)
{}
//${WheelDrives::UnBumpedEvt} ................................................
//${WheelDrives::UnBumpedEvt::UnBumpedEvt} ...................................
UnBumpedEvt::UnBumpedEvt(uint16_t seq, enum_t position)
  :BumpedEvt(WHEEL_DRIVES_BUMPER_UNBUMPED_SIG, seq, position)
{}
//${WheelDrives::HeadingRequestEvt} ..........................................
//${WheelDrives::HeadingRequestEv~::HeadingRequestEvt} .......................
HeadingRequestEvt::HeadingRequestEvt(uint16_t seq, std::shared_ptr<Goal> goal)
   :Evt(WHEEL_DRIVES_DD_HEADING_SIG, seq)
    , m_goal(goal)
{}
//${WheelDrives::WheelMoveRequestEvt} ........................................
//${WheelDrives::WheelMoveRequest~::WheelMoveRequestEvt} .....................
WheelMoveRequestEvt::WheelMoveRequestEvt(uint16_t seq, std::shared_ptr<OneDVelocityGoal> goal)
   :Evt(WHEEL_DRIVES_WHEEL_MOVE_REQ_SIG, seq)
    , m_goal(goal)
{}
//${WheelDrives::WheelTimeoutEvt} ............................................
//${WheelDrives::WheelTimeoutEvt::WheelTimeoutEvt} ...........................
WheelTimeoutEvt::WheelTimeoutEvt(uint8_t wheelId)
   :Evt(WHEEL_DRIVES_WHEEL_TIMEOUT_SIG)
    , m_wheelId(wheelId)
{}

} // namespace WheelDrives
