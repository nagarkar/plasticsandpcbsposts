//****************************************************************************
// Model: StdEvents.qm
// File:  stdevents/active_events.h
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${stdevents::active_events.h} ..............................................
#ifndef STDEVENTS_H
#define STDEVENTS_H

#include <stdio.h>
#include <stdlib.h>
#include "qpcpp.h"
#include "macros.h"
#include "app_ao_config.h"

using namespace QP;

#define EVT_CAST(e_)            static_cast<StdEvents::Evt const &>(e_)
#define ERROR_EVT_CAST(e_)      static_cast<StdEvents::ErrorEvt const &>(e_)

namespace StdEvents {
    // Common error code for all HSM's.
    enum Error {
        ERROR_SUCCESS,      // No error, success.
        ERROR_UNSPEC,       // Unspecified.
        ERROR_TIMEOUT,      // Timeout.
        ERROR_HAL,          // HAL driver error.
        ERROR_HARDWARE,     // Hardware error.
        ERROR_STATE,        // Invalid state.
        ERROR_UNAVAIL,      // Resource unavailable, busy.
    };

    // HSM specific reason code to explain why an error code has occurred.
    // When unused it is default to 0.
    typedef uint16_t Reason;

}// namespace FW
namespace StdEvents {


#if ((QP_VERSION < 580) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpcpp version 5.8.0 or higher required
#endif

//${StdEvents::Evt} ..........................................................
class Evt : public QP::QEvt {
protected:
    uint16_t m_seq;

public:
    Evt(QP::QSignal signal, uint16_t seq = 0)
    : QP::QEvt(signal), m_seq(seq)
    {}
    ~Evt();
    uint16_t GetSeq() const {
        return m_seq;
    }
    static void * operator new(size_t evtSize);
    static void operator delete(void * evt);
};
//${StdEvents::ErrorEvt} .....................................................
class ErrorEvt : public StdEvents::Evt {
protected:

    // Common error code.
    Error m_error;

    // CFM/RSP event specific reason code
    Reason m_reason;

public:
    ErrorEvt(
        QP::QSignal signal,
        uint16_t seq = 0,
        Error  error = ERROR_SUCCESS,
        Reason reason = 0)
    :Evt(signal, seq), m_error(error), m_reason(reason)
    {}
    Error GetError() const {
        return m_error;
    }
    Reason GetReason() const {
        return m_reason;
    }
    ErrorEvt(
        QP::QSignal signal,
        uint16_t seq = 0,
        ErrorEvt sourceEvt)
      :Evt(signal, seq)
       , m_error(sourceEvt.m_error)
       , m_reason(sourceEvt.m_reason)
    {}
};
//${StdEvents::AO} ...........................................................
class AO : public QP::QActive {
protected:
    enum  { EVT_QUEUE_COUNT = 16, DEFER_QUEUE_COUNT = 4 };
    QEvt const * m_evtQueueStor[EVT_QUEUE_COUNT];
    uint16_t  m_nextSequence;
    QTimeEvt m_timer;
    QEvt const * m_deferQueueStor[DEFER_QUEUE_COUNT];
    QEQueue m_deferQueue;

public:
    char const * m_name;
    uint8_t m_confirmationCount;

public:
    AO(
        enum_t  timeoutSignal,
        QStateHandler initialPseudoState,
        char const * name = "Missing a name")
    : QActive(initialPseudoState)
      , m_nextSequence(0)
      , m_timer(this, timeoutSignal)
      , m_name(name)
      , m_confirmationCount(0)
    {}
    void Start(uint8_t  prio) {
        QActive::start(prio, m_evtQueueStor, ARRAY_COUNT(m_evtQueueStor), NULL, 0);
        m_deferQueue.init(m_deferQueueStor, ARRAY_COUNT(m_deferQueueStor));
    }
    void ResetConfirmationCount();
    void HandleCfm(
        ErrorEvt const & e,
        uint16_t expectedCount,
        QSignal doneSignal,
        QSignal failureSignal);
    void Publish(QSignal signal);
    void RecallDeferred();
    void Defer(QEvt const * const  e);
    void PublishError(
        ErrorEvt const & errorEvt,
        uint16_t seq,
        QSignal errorSignal);
    void PublishConfirmationWithInvalidState(Evt const & e, QSignal signal);
    void PublishConfirmation(Evt const & e, QSignal signal);
};
//${StdEvents::ASM} ..........................................................
class ASM : public QP::QHsm {
protected:
    enum  { DEFER_QUEUE_COUNT = 4 };
    uint16_t  m_nextSequence;
    QTimeEvt m_timer;
    QEvt const * m_deferQueueStor[DEFER_QUEUE_COUNT];
    QEQueue m_deferQueue;
    QP::QActive m_owner;
    char const * m_name;

public:
    uint8_t m_confirmationCount;

public:
    ASM(
        enum_t timeoutSignal,
        QStateHandler initialPseudoState,
        QP::QActive * owner,
        char const * name = "Missing a Name")
    : QHsm(initialPseudoState)
      , m_nextSequence(0)
      , m_timer(owner, timeoutSignal)
      , m_owner(owner)
      , m_name(name)
    {}
    void Init() {
        QHsm::init();
        m_deferQueue.init(m_deferQueueStor, ARRAY_COUNT(m_deferQueueStor));
    }
    void HandleCfm(
        ErrorEvt const & e,
        uint16_t expectedCount,
        QSignal doneSignal,
        QSignal failureSignal);
    void ResetConfirmationCount();
    void Publish(QSignal signal);
    void RecallDeferred();
    void Defer(QEvt const * const  e);
    void PublishError(
        ErrorEvt const & errorEvt,
        uint16_t seq,
        QSignal errorSignal);
    void PublishConfirmationWithInvalidState(Evt const & e, QSignal signal);
    void PublishConfirmation(Evt const & e, QSignal signal);
    void PublishTimeout(QSignal signal);
    void PostToOwnerLifo(QSignal signal);
    void PostToOwnerLifo(QEvt *e e);
};

} // namespace StdEvents
#endif
