//****************************************************************************
// Model: StdEvents.qm
// File:  stdevents/active_events.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${stdevents::active_events.cpp} ............................................
#include "active_events.h"
#include <stdio.h>
#include <stdlib.h>

Q_DEFINE_THIS_MODULE("Standard Events")

using namespace QP;

namespace StdEvents {


#if ((QP_VERSION < 580) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpcpp version 5.8.0 or higher required
#endif

//${StdEvents::Evt} ..........................................................



//${StdEvents::Evt::operator new} ............................................
void * Evt::operator new(size_t evtSize) {
    return QF::newX_(evtSize, 0, 0);
}
//${StdEvents::Evt::operator delete} .........................................
void Evt::operator delete(void * evt) {
    (void)evt;    // Avoid warning.
    Q_ASSERT(0);
}//${StdEvents::ErrorEvt} .....................................................



//${StdEvents::AO} ...........................................................


//${StdEvents::AO::ResetConfirmationCount} ...................................
void AO::ResetConfirmationCount() {
    m_confirmationCount = 0;
}
//${StdEvents::AO::HandleCfm} ................................................
void AO::HandleCfm(
    ErrorEvt const & e,
    uint16_t expectedCount,
    QSignal doneSignal,
    QSignal failureSignal)
{
    m_confirmationCount++;
    if (e.GetError() == ERROR_SUCCESS) {
        // TODO - Compare seqeuence number.
        if(m_confirmationCount == expectedCount) {
            Evt *evt = new Evt(doneSignal);
            postLIFO(evt);
        }
    } else {
        Evt *evt = new ErrorEvt(failureSignal, e, m_nextSequence++);
        postLIFO(evt);
    }
}
//${StdEvents::AO::Publish} ..................................................
void AO::Publish(QSignal signal) {
    Evt *e = new Evt(signal, m_nextSequence++);
    QF::PUBLISH(e, this);
}
//${StdEvents::AO::RecallDeferred} ...........................................
void AO::RecallDeferred() {
    recall(&m_deferQueue);
}
//${StdEvents::AO::Defer} ....................................................
void AO::Defer(QEvt const * const  e) {
    defer(&m_deferQueue, e);
}
//${StdEvents::AO::PublishError} .............................................
void AO::PublishError(
    ErrorEvt const & errorEvt,
    uint16_t seq,
    QSignal errorSignal)
{
    ErrorEvt *evt = new ErrorEvt(errorSignal, errorEvt, seq);
    QF::PUBLISH(evt, this);
}
//${StdEvents::AO::PublishConfirmationWithInvalidSt~} ........................
void AO::PublishConfirmationWithInvalidState(Evt const & e, QSignal signal) {
    ErrorEvt *evt = new ErrorEvt(signal, e.GetSeq(), ERROR_STATE);
    QF::PUBLISH(evt, this);
}
//${StdEvents::AO::PublishConfirmation} ......................................
void AO::PublishConfirmation(Evt const & e, QSignal signal) {
    ErrorEvt *evt = new ErrorEvt(signal, e.GetSeq(), ERROR_SUCCESS);
    QF::PUBLISH(evt, this);
}//${StdEvents::ASM} ..........................................................


//${StdEvents::ASM::HandleCfm} ...............................................
void ASM::HandleCfm(
    ErrorEvt const & e,
    uint16_t expectedCount,
    QSignal doneSignal,
    QSignal failureSignal)
{
    m_confirmationCount++;
    if (e.GetError() == ERROR_SUCCESS) {
        // TODO - Compare seqeuence number.
        if(m_confirmationCount == expectedCount) {
            PostToOwnerLifo(doneSignal);
        }
    } else {
        Evt *evt = new ErrorEvt(failureSignal, e, m_nextSequence++);
        PostToOwnerLifo(evt);
    }
}
//${StdEvents::ASM::ResetConfirmationCount} ..................................
void ASM::ResetConfirmationCount() {
    m_confirmationCount = 0;
}
//${StdEvents::ASM::Publish} .................................................
void ASM::Publish(QSignal signal) {
    Evt *e = new Evt(signal, m_nextSequence++);
    QF::PUBLISH(e, this);
}
//${StdEvents::ASM::RecallDeferred} ..........................................
void ASM::RecallDeferred() {
    m_owner->recall(&m_deferQueue);
}
//${StdEvents::ASM::Defer} ...................................................
void ASM::Defer(QEvt const * const  e) {
    m_owner->defer(&m_deferQueue, e);
}
//${StdEvents::ASM::PublishError} ............................................
void ASM::PublishError(
    ErrorEvt const & errorEvt,
    uint16_t seq,
    QSignal errorSignal)
{
    ErrorEvt *evt = new ErrorEvt(errorSignal, errorEvt, seq);
    QF::PUBLISH(evt, this);
}
//${StdEvents::ASM::PublishConfirmationWithInvalidSt~} .......................
void ASM::PublishConfirmationWithInvalidState(Evt const & e, QSignal signal) {
    ErrorEvt *evt = new ErrorEvt(signal, e.GetSeq(), ERROR_STATE);
    QF::PUBLISH(evt, this);
}
//${StdEvents::ASM::PublishConfirmation} .....................................
void ASM::PublishConfirmation(Evt const & e, QSignal signal) {
    ErrorEvt *evt = new ErrorEvt(signal, e.GetSeq(), ERROR_SUCCESS);
    QF::PUBLISH(evt, this);
}
//${StdEvents::ASM::PublishTimeout} ..........................................
void ASM::PublishTimeout(QSignal signal) {
    ErrorEvt *e = new ErrorEvt(signal, m_nextSequence++, ERROR_TIMEOUT);
    QF::PUBLISH(e, this);
}
//${StdEvents::ASM::PostToOwnerLifo} .........................................
void ASM::PostToOwnerLifo(QSignal signal) {
    Evt *e = new Evt(signal, m_nextSequence++);
    m_owner->postLIFO(e);
}
//${StdEvents::ASM::PostToOwnerLifo} .........................................
void ASM::PostToOwnerLifo(QEvt * e) {
    m_owner->postLIFO(e);
}
} // namespace StdEvents
