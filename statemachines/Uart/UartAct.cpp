//****************************************************************************
// Model: Uart.qm
// File:  Uart/UartAct.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${Uart::Uart::UartAct.cpp} .................................................
#include "UartAct.h"
#include "UartIn.h"
#include "UartOut.h"
#include "qpcpp.h"
#include "active_events.h"
#include "active_log.h"
#include "bsp.h"

Q_DEFINE_THIS_MODULE("Uart Active")

using namespace QP;
using namespace StdEvents;

namespace AOs {


#if ((QP_VERSION < 580) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpcpp version 5.8.0 or higher required
#endif

//${Uart::UartAct} ...........................................................
//${Uart::UartAct::UartAct} ..................................................
UartAct::UartAct(USART_HANDLE_TYPE_DEF * devUart)
  : AO(UART_ACT_STATE_TIMER_SIG, (QStateHandler)&UartAct::initial, "UartAct")
    , m_devUart(devUart)
    , m_inFifo(m_inFifoStorage, UART_IN_FIFO_BLOCK_SIZE)
    , m_outFifo(m_outFifoStorage, UART_OUT_FIFO_BLOCK_SIZE)
    , m_uartIn(this, &m_inFifo, devUart)
    , m_uartOut(this, &m_outFifo, devUart)
{
    uint32_t timeout = UartAct::STARTING_STOPPING_TIMEOUT;
    Q_ASSERT(timeout >= UartIn::STARTING_STOPPING_TIMEOUT);
    Q_ASSERT(timeout >= UartOut::STARTING_STOPPING_TIMEOUT);
}

//${Uart::UartAct::GetInFifo} ................................................
Fifo & UartAct::GetInFifo() {
    return m_inFifo;
}
//${Uart::UartAct::SM} .......................................................
QP::QState UartAct::initial(UartAct * const me, QP::QEvt const * const e) {
    // ${Uart::UartAct::SM::initial}
    me->subscribe(UART_ACT_START_REQ_SIG);
    me->subscribe(UART_ACT_STOP_REQ_SIG);
    me->subscribe(UART_ACT_STATE_TIMER_SIG);
    me->subscribe(UART_ACT_START_SIG);
    me->subscribe(UART_ACT_DONE_SIG);
    me->subscribe(UART_ACT_FAIL_SIG);

    me->subscribe(UART_OUT_START_REQ_SIG);
    me->subscribe(UART_OUT_START_CFM_SIG);
    me->subscribe(UART_OUT_STOP_REQ_SIG);
    me->subscribe(UART_OUT_STOP_CFM_SIG);
    me->subscribe(UART_OUT_FAIL_IND_SIG);
    me->subscribe(UART_OUT_WRITE_REQ_SIG);
    me->subscribe(UART_OUT_ACTIVE_TIMER_SIG);
    me->subscribe(UART_OUT_DONE_SIG);
    me->subscribe(UART_OUT_DMA_DONE_SIG);
    me->subscribe(UART_OUT_CONTINUE_SIG);
    me->subscribe(UART_OUT_HW_FAIL_SIG);

    me->subscribe(UART_IN_START_REQ_SIG);
    me->subscribe(UART_IN_START_CFM_SIG);
    me->subscribe(UART_IN_STOP_REQ_SIG);
    me->subscribe(UART_IN_STOP_CFM_SIG);
    me->subscribe(UART_IN_ACTIVE_TIMER_SIG);
    me->subscribe(UART_IN_DONE_SIG);
    me->subscribe(UART_IN_DATA_RDY_SIG);
    me->subscribe(UART_IN_DATA_IND_SIG);
    me->subscribe(UART_IN_DMA_RECV_SIG);
    me->subscribe(UART_IN_OVERFLOW_SIG);
    me->subscribe(UART_IN_HW_FAIL_SIG);
    return Q_TRAN(&Root);
}
//${Uart::UartAct::SM::Root} .................................................
QP::QState UartAct::Root(UartAct * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${Uart::UartAct::SM::Root}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            me->m_uartIn.Init();
            me->m_uartOut.Init();
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root}
        case Q_EXIT_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::initial}
        case Q_INIT_SIG: {
            LOG_EVENT(e);
            status_ = Q_TRAN(&Stopped);
            break;
        }
        // ${Uart::UartAct::SM::Root::UART_ACT_STOP_REQ}
        case UART_ACT_STOP_REQ_SIG: {
            LOG_EVENT(e);
            status_ = Q_TRAN(&Stopping);
            break;
        }
        // ${Uart::UartAct::SM::Root::UART_OUT_START_REQ,UART_OUT_STOP~}
        case UART_OUT_START_REQ_SIG: // intentionally fall through
        case UART_OUT_STOP_REQ_SIG: // intentionally fall through
        case UART_OUT_WRITE_REQ_SIG: // intentionally fall through
        case UART_OUT_ACTIVE_TIMER_SIG: // intentionally fall through
        case UART_OUT_DONE_SIG: // intentionally fall through
        case UART_OUT_DMA_DONE_SIG: // intentionally fall through
        case UART_OUT_CONTINUE_SIG: // intentionally fall through
        case UART_OUT_HW_FAIL_SIG: {
            //LOG_EVENT(e);
            me->m_uartOut.dispatch(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::UART_IN_START_REQ,UART_IN_STOP_R~}
        case UART_IN_START_REQ_SIG: // intentionally fall through
        case UART_IN_STOP_REQ_SIG: // intentionally fall through
        case UART_IN_ACTIVE_TIMER_SIG: // intentionally fall through
        case UART_IN_DONE_SIG: // intentionally fall through
        case UART_IN_DATA_RDY_SIG: // intentionally fall through
        case UART_IN_DMA_RECV_SIG: // intentionally fall through
        case UART_IN_OVERFLOW_SIG: // intentionally fall through
        case UART_IN_HW_FAIL_SIG: {
            //LOG_EVENT(e);
            me->m_uartIn.dispatch(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::UART_IN_DATA_IND}
        case UART_IN_DATA_IND_SIG: {
            LOG_EVENT(e);
            uint32_t count = me->m_inFifo.GetUsedCount();
            while(count--) {
                uint8_t ch;
                me->m_inFifo.Read(&ch, 1);
                PRINT("%c", ch);
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&top);
            break;
        }
    }
    return status_;
}
//${Uart::UartAct::SM::Root::Stopped} ........................................
QP::QState UartAct::Stopped(UartAct * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${Uart::UartAct::SM::Root::Stopped}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::Stopped}
        case Q_EXIT_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::Stopped::UART_ACT_START_REQ}
        case UART_ACT_START_REQ_SIG: {
            LOG_EVENT(e);
            // TODO: 1. Initialize UART with parameters passed into the event
            // TODO: 2. Publish failure event if initialization fails.
            Evt *evt = new Evt(UART_ACT_START_SIG);
            me->postLIFO(evt);
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::Stopped::UART_ACT_START}
        case UART_ACT_START_SIG: {
            LOG_EVENT(e);
            status_ = Q_TRAN(&Starting);
            break;
        }
        // ${Uart::UartAct::SM::Root::Stopped::UART_ACT_STOP_REQ}
        case UART_ACT_STOP_REQ_SIG: {
            LOG_EVENT(e);Evt const &req = EVT_CAST(*e);
            Evt * evt = new ErrorEvt(UART_ACT_STOP_CFM_SIG, req.GetSeq(), ERROR_SUCCESS);
            QF::PUBLISH(evt, me);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${Uart::UartAct::SM::Root::Starting} .......................................
QP::QState UartAct::Starting(UartAct * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${Uart::UartAct::SM::Root::Starting}
        case Q_ENTRY_SIG: {
            uint32_t timeout = me->STARTING_STOPPING_TIMEOUT;
            me->m_timer.armX(timeout);
            me->ResetConfirmationCount();

            Evt *evt = new Evt(UART_OUT_START_REQ_SIG, me->m_nextSequence++);
            QF::PUBLISH(evt, me);

            evt = new Evt(UART_IN_START_REQ_SIG, me->m_nextSequence++);
            QF::PUBLISH(evt, me);
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::Starting}
        case Q_EXIT_SIG: {
            LOG_EVENT(e);
            me->m_timer.disarm();
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::Starting::UART_OUT_START_CFM,UART_IN_START~}
        case UART_OUT_START_CFM_SIG: // intentionally fall through
        case UART_IN_START_CFM_SIG: {
            LOG_EVENT(e);
            me->HandleCfm(
                ERROR_EVT_CAST(*e),
                2,
                UART_ACT_DONE_SIG,
                UART_ACT_FAIL_SIG);
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::Starting::UART_ACT_FAIL,UART_ACT_STATE_TIM~}
        case UART_ACT_FAIL_SIG: // intentionally fall through
        case UART_ACT_STATE_TIMER_SIG: {
            LOG_EVENT(e);
            Evt *evt;
            if (e->sig == UART_ACT_FAIL_SIG) {
                ErrorEvt const &fail = ERROR_EVT_CAST(*e);
                evt = new ErrorEvt(UART_ACT_START_CFM_SIG, 0, fail.GetError(), fail.GetReason());
            } else {
                evt = new ErrorEvt(UART_ACT_START_CFM_SIG, 0, ERROR_TIMEOUT);
            }
            QF::PUBLISH(evt, me);
            status_ = Q_TRAN(&Stopping);
            break;
        }
        // ${Uart::UartAct::SM::Root::Starting::UART_ACT_DONE}
        case UART_ACT_DONE_SIG: {
            LOG_EVENT_NOQP(e);
            Evt *evt = new ErrorEvt(UART_ACT_START_CFM_SIG, 0, ERROR_SUCCESS);
            QF::PUBLISH(evt, me);
            status_ = Q_TRAN(&Started);
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${Uart::UartAct::SM::Root::Stopping} .......................................
QP::QState UartAct::Stopping(UartAct * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${Uart::UartAct::SM::Root::Stopping}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            uint32_t timeout = UartAct::STARTING_STOPPING_TIMEOUT;
            me->m_timer.armX(timeout);
            me->ResetConfirmationCount();

            me->Publish(UART_IN_STOP_REQ_SIG);
            me->Publish(UART_OUT_STOP_REQ_SIG);
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::Stopping}
        case Q_EXIT_SIG: {
            LOG_EVENT(e);
            me->m_timer.disarm();
            me->RecallDeferred();
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::Stopping::UART_ACT_STOP_REQ}
        case UART_ACT_STOP_REQ_SIG: {
            LOG_EVENT(e);
            me->Defer(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::Stopping::UART_IN_STOP_CFM,UART_OUT_STOP_C~}
        case UART_IN_STOP_CFM_SIG: // intentionally fall through
        case UART_OUT_STOP_CFM_SIG: {
            LOG_EVENT(e);
            me->HandleCfm(
                ERROR_EVT_CAST(*e),
                2,
                UART_ACT_DONE_SIG,
                UART_ACT_FAIL_SIG);
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::Stopping::UART_ACT_DONE}
        case UART_ACT_DONE_SIG: {
            LOG_EVENT(e);
            Evt *evt = new ErrorEvt(UART_ACT_STOP_CFM_SIG, 0, ERROR_SUCCESS);
            QF::PUBLISH(evt, me);
            status_ = Q_TRAN(&Stopped);
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${Uart::UartAct::SM::Root::Started} ........................................
QP::QState UartAct::Started(UartAct * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${Uart::UartAct::SM::Root::Started}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            Log::AddQPInterface(&me->m_outFifo, UART_OUT_WRITE_REQ_SIG);
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::Started}
        case Q_EXIT_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::Started::initial}
        case Q_INIT_SIG: {
            LOG_EVENT(e);
            status_ = Q_TRAN(&Normal);
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${Uart::UartAct::SM::Root::Started::Normal} ................................
QP::QState UartAct::Normal(UartAct * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${Uart::UartAct::SM::Root::Started::Normal}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::Started::Normal}
        case Q_EXIT_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::Started::Normal::UART_IN_FAIL_IND,UART_OUT_FAIL_I~}
        case UART_IN_FAIL_IND_SIG: // intentionally fall through
        case UART_OUT_FAIL_IND_SIG: {
            LOG_EVENT(e);
            me->PublishError(
                ERROR_EVT_CAST(*e),
                me->m_nextSequence++,
                UART_ACT_FAIL_IND_SIG);
            status_ = Q_TRAN(&Failed);
            break;
        }
        default: {
            status_ = Q_SUPER(&Started);
            break;
        }
    }
    return status_;
}
//${Uart::UartAct::SM::Root::Started::Failed} ................................
QP::QState UartAct::Failed(UartAct * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${Uart::UartAct::SM::Root::Started::Failed}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${Uart::UartAct::SM::Root::Started::Failed}
        case Q_EXIT_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Started);
            break;
        }
    }
    return status_;
}

} // namespace AOs
