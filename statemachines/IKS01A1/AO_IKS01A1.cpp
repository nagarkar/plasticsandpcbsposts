//****************************************************************************
// Model: AO_IKS01A1.qm
// File:  IKS01A1/AO_IKS01A1.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${IKS01A1::IKS01A1::AO_IKS01A1.cpp} ........................................
#include "AO_IKS01A1.h"
#include "x_nucleo_iks01a1_accelero.h"
#include "CircularBuffer.h"
#include "app_ao_config.h"
#include "active_log.h"

using namespace StdEvents;
using namespace QP;

namespace IKS01A1 {
    void SensorAxesBufferElement::print() {
        PRINT("%d\t%d\t%d\t%d\r\n", timestamp, axes.AXIS_X, axes.AXIS_Y, axes.AXIS_Z);
    }
}// namespace

namespace IKS01A1 {


#if ((QP_VERSION < 580) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpcpp version 5.8.0 or higher required
#endif

//${IKS01A1::AO_IKS01A1} .....................................................
//${IKS01A1::AO_IKS01A1::AO_IKS01A1} .........................................
AO_IKS01A1::AO_IKS01A1(uint32_t interval)
  : AO(IKS01A1_ACC_INTERVAL_TIMER_SIG,
        (QStateHandler)&initial,
        "IKS01A1")
    , m_dataCollectionInterval(interval)
    , m_circbuf(m_buffer, ACC_BUFFER_SIZE)
{}

//${IKS01A1::AO_IKS01A1::armTimer} ...........................................
void AO_IKS01A1::armTimer() {
    m_timer.disarm();
    m_timer.armX(m_dataCollectionInterval, 0);
}
//${IKS01A1::AO_IKS01A1::SM} .................................................
QP::QState AO_IKS01A1::initial(AO_IKS01A1 * const me, QP::QEvt const * const e) {
    // ${IKS01A1::AO_IKS01A1::SM::initial}
    me->subscribe(IKS01A1_ACC_STOP_REQ_SIG);
    me->subscribe(IKS01A1_ACC_STOP_CFM_SIG);
    me->subscribe(IKS01A1_ACC_START_REQ_SIG);
    me->subscribe(IKS01A1_ACC_START_CFM_SIG);
    me->subscribe(IKS01A1_ACC_INTERVAL_TIMER_SIG);
    me->subscribe(IKS01A1_ACC_COMPONENT_FAILED_SIG);
    return Q_TRAN(&Root);
}
//${IKS01A1::AO_IKS01A1::SM::Root} ...........................................
QP::QState AO_IKS01A1::Root(AO_IKS01A1 * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${IKS01A1::AO_IKS01A1::SM::Root::initial}
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Stopped);
            break;
        }
        default: {
            status_ = Q_SUPER(&top);
            break;
        }
    }
    return status_;
}
//${IKS01A1::AO_IKS01A1::SM::Root::Stopped} ..................................
QP::QState AO_IKS01A1::Stopped(AO_IKS01A1 * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${IKS01A1::AO_IKS01A1::SM::Root::Stopped}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${IKS01A1::AO_IKS01A1::SM::Root::Stopped::IKS01A1_ACC_START_REQ}
        case IKS01A1_ACC_START_REQ_SIG: {
            LOG_EVENT(e);
            me->PublishConfirmation(
                EVT_CAST(*e),
                IKS01A1_ACC_START_CFM_SIG);
            status_ = Q_TRAN(&Started);
            break;
        }
        // ${IKS01A1::AO_IKS01A1::SM::Root::Stopped::IKS01A1_ACC_STOP_REQ}
        case IKS01A1_ACC_STOP_REQ_SIG: {
            LOG_EVENT(e);
            me->PublishConfirmation(
                EVT_CAST(*e),
                IKS01A1_ACC_STOP_CFM_SIG);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${IKS01A1::AO_IKS01A1::SM::Root::Started} ..................................
QP::QState AO_IKS01A1::Started(AO_IKS01A1 * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${IKS01A1::AO_IKS01A1::SM::Root::Started}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            if (me->m_xInitStatus != COMPONENT_OK) {
                me->m_xInitStatus = BSP_ACCELERO_Init(LSM6DS0_X_0, &me->m_handle);
                if (me->m_xInitStatus == COMPONENT_OK) {
                    BSP_ACCELERO_Sensor_Enable(me->m_handle);
                }
            }
            //BSP_ACCELERO_Sensor_Enable(me->m_handle);
            status_ = Q_HANDLED();
            break;
        }
        // ${IKS01A1::AO_IKS01A1::SM::Root::Started}
        case Q_EXIT_SIG: {
            LOG_EVENT(e);
            //BSP_ACCELERO_Sensor_Disable(me->m_handle);
            //BSP_ACCELERO_DeInit(&me->m_handle);
            //me->m_timer.disarm();
            status_ = Q_HANDLED();
            break;
        }
        // ${IKS01A1::AO_IKS01A1::SM::Root::Started::initial}
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&CollectingData);
            break;
        }
        // ${IKS01A1::AO_IKS01A1::SM::Root::Started::IKS01A1_ACC_STOP_REQ}
        case IKS01A1_ACC_STOP_REQ_SIG: {
            LOG_EVENT(e);
            me->PublishConfirmation(
                EVT_CAST(*e),
                IKS01A1_ACC_STOP_CFM_SIG);
            status_ = Q_TRAN(&Stopped);
            break;
        }
        // ${IKS01A1::AO_IKS01A1::SM::Root::Started::IKS01A1_ACC_START_REQ}
        case IKS01A1_ACC_START_REQ_SIG: {
            LOG_EVENT(e);
            me->PublishConfirmation(
                EVT_CAST(*e),
                IKS01A1_ACC_START_CFM_SIG);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${IKS01A1::AO_IKS01A1::SM::Root::Started::CollectingData} ..................
QP::QState AO_IKS01A1::CollectingData(AO_IKS01A1 * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${IKS01A1::AO_IKS01A1::SM::Root::Started::CollectingData}
        case Q_ENTRY_SIG: {

            uint32_t const interval = me->m_dataCollectionInterval;
            me->m_timer.armX(interval, interval);
            status_ = Q_HANDLED();
            break;
        }
        // ${IKS01A1::AO_IKS01A1::SM::Root::Started::CollectingData}
        case Q_EXIT_SIG: {

            me->m_timer.disarm();
            status_ = Q_HANDLED();
            break;
        }
        // ${IKS01A1::AO_IKS01A1::SM::Root::Started::CollectingData::IKS01A1_ACC_COMPONENT_FAILED}
        case IKS01A1_ACC_COMPONENT_FAILED_SIG: {
            LOG_EVENT(e);
            status_ = Q_TRAN(&Failed);
            break;
        }
        // ${IKS01A1::AO_IKS01A1::SM::Root::Started::CollectingData::IKS01A1_ACC_INTERVAL_TIMER}
        case IKS01A1_ACC_INTERVAL_TIMER_SIG: {
            SensorAxes_t acceleration;
            DrvStatusTypeDef result;
            result = BSP_ACCELERO_Get_Axes(me->m_handle, &acceleration);
            if (result != COMPONENT_OK) {
                me->Publish(IKS01A1_ACC_COMPONENT_FAILED_SIG);
            } else {
                SensorAxesBufferElement el(acceleration);
                me->m_circbuf.push(el);
                if (me->m_xPrintStream) {
                   el.print();
                }
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Started);
            break;
        }
    }
    return status_;
}
//${IKS01A1::AO_IKS01A1::SM::Root::Started::Failed} ..........................
QP::QState AO_IKS01A1::Failed(AO_IKS01A1 * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${IKS01A1::AO_IKS01A1::SM::Root::Started::Failed}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Started);
            break;
        }
    }
    return status_;
}

} // namespace IKS01A1
