//****************************************************************************
// Model: LED_BUTTON_AND_INTERRUPT.qm
// File:  E:\repositories\plasticsandpcbsposts\sw4stm32\QPIntegration2\App\Src/UserLed.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${AOs::E:\repositories\~::UserLed.cpp} .....................................
#include <stdio.h>
#include <stdlib.h>
#include "UserLed.h"

Q_DEFINE_THIS_FILE

using namespace QP;

void Q_onAssert(char const Q_ROM * const Q_ROM_VAR file, int line) {
    fprintf(stderr, "Assertion failed in %s, line %d", file, line);
    exit(0);
}
void QF::onStartup(void) {}
void QF::onCleanup(void) {}

enum UserLedSignals {
    TIMEOUT_SIG = Q_USER_SIG,
    BUTTON_PRESS_SIG,
    MAX_SIG
};
/*************** ask QM to define the Blinky class  ******************/
namespace AOs {


#if ((QP_VERSION < 580) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpcpp version 5.8.0 or higher required
#endif

//${AOs::UserLed} ............................................................
//${AOs::UserLed::UserLed} ...................................................
UserLed::UserLed()
 : QActive((QStateHandler)(&UserLed::initial))
{}

//${AOs::UserLed::SM} ........................................................
QP::QState UserLed::initial(UserLed * const me, QP::QEvt const * const e) {
    // ${AOs::UserLed::SM::initial}
    //(void)e; // suppress the compiler warning about unused parameter
    //QS_FUN_DICTIONARY(&QP::QHsm::top);
    return Q_TRAN(&OFF);
}
//${AOs::UserLed::SM::ON} ....................................................
QP::QState UserLed::ON(UserLed * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AOs::UserLed::SM::ON::BUTTON_PRESS}
        case BUTTON_PRESS_SIG: {
            status_ = Q_TRAN(&OFF);
            break;
        }
        // ${AOs::UserLed::SM::ON::TIMEOUT}
        case TIMEOUT_SIG: {
            status_ = Q_TRAN(&OFF);
            break;
        }
        default: {
            status_ = Q_SUPER(&top);
            break;
        }
    }
    return status_;
}
//${AOs::UserLed::SM::OFF} ...................................................
QP::QState UserLed::OFF(UserLed * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AOs::UserLed::SM::OFF::BUTTON_PRESS}
        case BUTTON_PRESS_SIG: {
            status_ = Q_TRAN(&ON);
            break;
        }
        default: {
            status_ = Q_SUPER(&top);
            break;
        }
    }
    return status_;
}

} // namespace AOs
