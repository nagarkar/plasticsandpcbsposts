//****************************************************************************
// Model: LED_BUTTON_AND_INTERRUPT.qm
// File:  E:\repositories\plasticsandpcbsposts\sw4stm32\QPIntegration2\App\Src/blinky.c
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${AOs::E:\repositories\~::blinky.c} ........................................
#include "qpcpp.h"
#include <stdio.h>
#include <stdlib.h>
#include "qep.h"
#define BSP_TICKS_PER_SEC 100

using namespace QP;

void Q_onAssert(char const Q_ROM * const Q_ROM_VAR file, int line) {
    fprintf(stderr, "Assertion failed in %s, line %d", file, line);
    exit(0);
}
void QF_onStartup(void) {}
void QF_onCleanup(void) {}

enum BlinkySignals {
    TIMEOUT_SIG = Q_USER_SIG,
	BUTTON_PRESS_SIG,
    MAX_SIG
};
/*************** ask QM to declare the Blinky class ******************/

#if ((QP_VERSION < 580) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpcpp version 5.8.0 or higher required
#endif

//${AOs::Blinky} .............................................................
class Blinky : public QP::QActive {
private:
    QTimeEvt timeEvt;

protected:
    static QP::QState initial(Blinky * const me, QP::QEvt const * const e);
    static QP::QState ON(Blinky * const me, QP::QEvt const * const e);
    static QP::QState OFF(Blinky * const me, QP::QEvt const * const e);
};

/*************** ask QM to define the Blinky class  ******************/
//${AOs::Blinky} .............................................................
//${AOs::Blinky::SM} .........................................................

QP::QState Blinky::initial(Blinky * const me, QP::QEvt const * const e) {
    // ${AOs::Blinky::SM::initial}
    return Q_TRAN(&OFF);
}
//${AOs::Blinky::SM::ON} .....................................................
QP::QState Blinky::ON(Blinky * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AOs::Blinky::SM::ON::BUTTON_PRESS}
        case BUTTON_PRESS_SIG: {
            status_ = Q_TRAN(&OFF);
            break;
        }
        // ${AOs::Blinky::SM::ON::TIMEOUT}
        case TIMEOUT_SIG: {
            status_ = Q_TRAN(&OFF);
            break;
        }
        default: {
            status_ = Q_SUPER(&top);
            break;
        }
    }
    return status_;
}
//${AOs::Blinky::SM::OFF} ....................................................
QP::QState Blinky::OFF(Blinky * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AOs::Blinky::SM::OFF::BUTTON_PRESS}
        case BUTTON_PRESS_SIG: {
            status_ = Q_TRAN(&ON);
            break;
        }
        default: {
            status_ = Q_SUPER(&top);
            break;
        }
    }
    return status_;
}

static Blinky l_blinky;

int main() {
    static QEvt const *blinky_queueSto[10];
    l_blinky = Blinky();
    QF::init();
    l_blinky.start(1U,blinky_queueSto, Q_DIM(blinky_queueSto),
                  (void *)0, 1024U, (QEvt *)0);
    return QF::run();
}
