//****************************************************************************
// Model: LED_BUTTON_AND_INTERRUPT.qm
// File:  E:\repositories\plasticsandpcbsposts\sw4stm32\QPCPPWithStm32Cube\SM\Src/UserLed.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${AOs::E:\repositories\~::UserLed.cpp} .....................................
#include <stdio.h>
#include <stdlib.h>
#include "bsp.h"
#include "events.h"
#include "UserLed.h"

Q_DEFINE_THIS_FILE

using namespace QP;

/*************** ask QM to define the Blinky class  ******************/
namespace AOs {


#if ((QP_VERSION < 580) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpcpp version 5.8.0 or higher required
#endif

//${AOs::UserLed} ............................................................
//${AOs::UserLed::UserLed} ...................................................
UserLed::UserLed()
 : QActive((QStateHandler)(&UserLed::initial))
{}

//${AOs::UserLed::LedOn} .....................................................
void UserLed::LedOn() {
    BSP_LedOn();
}
//${AOs::UserLed::LedOff} ....................................................
void UserLed::LedOff() {
    BSP_LedOff();
}
//${AOs::UserLed::SM} ........................................................
QP::QState UserLed::initial(UserLed * const me, QP::QEvt const * const e) {
    // ${AOs::UserLed::SM::initial}
    //(void)e; // suppress the compiler warning about unused parameter
    //QS_FUN_DICTIONARY(&QP::QHsm::top);
    return Q_TRAN(&OFF);
}
//${AOs::UserLed::SM::ON} ....................................................
QP::QState UserLed::ON(UserLed * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AOs::UserLed::SM::ON}
        case Q_ENTRY_SIG: {
            me->LedOn();
            status_ = Q_HANDLED();
            break;
        }
        // ${AOs::UserLed::SM::ON}
        case Q_EXIT_SIG: {
            me->LedOff();
            status_ = Q_HANDLED();
            break;
        }
        // ${AOs::UserLed::SM::ON::BUTTON_1_PRESS}
        case BUTTON_1_PRESS_SIG: {
            status_ = Q_TRAN(&OFF);
            break;
        }
        // ${AOs::UserLed::SM::ON::TIM_2_TIMEOUT}
        case TIM_2_TIMEOUT_SIG: {
            status_ = Q_TRAN(&OFF);
            break;
        }
        default: {
            status_ = Q_SUPER(&top);
            break;
        }
    }
    return status_;
}
//${AOs::UserLed::SM::OFF} ...................................................
QP::QState UserLed::OFF(UserLed * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AOs::UserLed::SM::OFF}
        case Q_ENTRY_SIG: {
            me->LedOff();
            status_ = Q_HANDLED();
            break;
        }
        // ${AOs::UserLed::SM::OFF::BUTTON_1_PRESS}
        case BUTTON_1_PRESS_SIG: {
            status_ = Q_TRAN(&ON);
            break;
        }
        default: {
            status_ = Q_SUPER(&top);
            break;
        }
    }
    return status_;
}

} // namespace AOs
