//****************************************************************************
// Model: calc1_sub.qm
// File:  ./calc1_sub.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following commercial QP license:
// License #   : QPCPP-EVAL-170201
// Issued to   : Company/individual evaluating the QP/C++ framework
// Framework(s): qpcpp
// Support ends: 2017-02-28
// Product(s)  :
// This license is available only for evaluation purposes and
// the generated code is still licensed under the terms of GPL.
// Please submit request for extension of the evaluaion period at:
// http://www.state-machine.com/licensing/index.html#RequestForm
//****************************************************************************
//${.::calc1_sub.cpp} ........................................................
#include "qpcpp.h" // QP/C++
#include "bsp.h"   // board support package
#include "calc1_sub.h" // application


#if ((QP_VERSION < 580) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpcpp version 5.8.0 or higher required
#endif

//${SMs::Calc} ...............................................................
class Calc : public QP::QMsm {
private:
    double m_op1;
    uint8_t m_oper;

public:
    Calc();

protected:
    struct SM_operand { // must be a POD
        QP::QMState super;
        QP::QActionHandler const ce; // eXit-Point segment

        static QP::QState zero_ep(Calc * const me);
        static QP::QState intgr_ep(Calc * const me);
        static QP::QState frac_ep(Calc * const me);
        static QP::QState neg_ep(Calc * const me);

        static QP::QState zero  (Calc * const me, QP::QEvt const * const e);
        static QP::QState zero_e(Calc * const me);
        static QP::QState zero_x(Calc * const me);
        static QP::QMState const zero_s;
        static QP::QState intgr  (Calc * const me, QP::QEvt const * const e);
        static QP::QState intgr_e(Calc * const me);
        static QP::QState intgr_x(Calc * const me);
        static QP::QMState const intgr_s;
        static QP::QState frac  (Calc * const me, QP::QEvt const * const e);
        static QP::QState frac_e(Calc * const me);
        static QP::QState frac_x(Calc * const me);
        static QP::QMState const frac_s;
        static QP::QState neg  (Calc * const me, QP::QEvt const * const e);
        static QP::QState neg_e(Calc * const me);
        static QP::QState neg_x(Calc * const me);
        static QP::QMState const neg_s;
    } const *sub_operand;
    friend struct SM_operand;
    static QP::QState initial(Calc * const me, QP::QEvt const * const e);
    static QP::QState on  (Calc * const me, QP::QEvt const * const e);
    static QP::QState on_e(Calc * const me);
    static QP::QState on_x(Calc * const me);
    static QP::QState on_i(Calc * const me);
    static QP::QMState const on_s;
    static QP::QState ready  (Calc * const me, QP::QEvt const * const e);
    static QP::QState ready_e(Calc * const me);
    static QP::QState ready_x(Calc * const me);
    static QP::QState ready_i(Calc * const me);
    static QP::QMState const ready_s;
    static QP::QState result  (Calc * const me, QP::QEvt const * const e);
    static QP::QState result_e(Calc * const me);
    static QP::QState result_x(Calc * const me);
    static QP::QMState const result_s;
    static QP::QState begin  (Calc * const me, QP::QEvt const * const e);
    static QP::QState begin_e(Calc * const me);
    static QP::QState begin_x(Calc * const me);
    static QP::QMState const begin_s;
    static QP::QState operand1  (Calc * const me, QP::QEvt const * const e);
    static QP::QState operand1_e(Calc * const me);
    static QP::QState operand1_ce(Calc * const me);
    static SM_operand const operand1_s;
    static QP::QState opEntered  (Calc * const me, QP::QEvt const * const e);
    static QP::QState opEntered_e(Calc * const me);
    static QP::QState opEntered_x(Calc * const me);
    static QP::QMState const opEntered_s;
    static QP::QState error  (Calc * const me, QP::QEvt const * const e);
    static QP::QState error_e(Calc * const me);
    static QP::QState error_x(Calc * const me);
    static QP::QMState const error_s;
    static QP::QState operand2  (Calc * const me, QP::QEvt const * const e);
    static QP::QState operand2_e(Calc * const me);
    static QP::QState operand2_ce(Calc * const me);
    static SM_operand const operand2_s;
    static QP::QState final  (Calc * const me, QP::QEvt const * const e);
    static QP::QState final_e(Calc * const me);
    static QP::QMState const final_s;

    static QP::QState operand  (Calc * const me, QP::QEvt const * const e);
    static QP::QState operand_e(Calc * const me);
    static QP::QState operand_x(Calc * const me);
    static QP::QState operand_i(Calc * const me);
    static QP::QMState const operand_s;
};


static Calc l_calc;    // the only instance of the Calc class

// global-scope definitions --------------------------------------
QP::QMsm * const the_calc = &l_calc;    // "opaque" pointer to MSM

//${SMs::Calc} ...............................................................
//${SMs::Calc::Calc} .........................................................
Calc::Calc()
  : QMsm(Q_STATE_CAST(&Calc::initial))
{}

//${SMs::Calc::SM} ...........................................................
QP::QState Calc::initial(Calc * const me, QP::QEvt const * const e) {
    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[3];
    } const tatbl_ = { // transition-action table
        &on_s, // target state
        {
            Q_ACTION_CAST(&on_e), // entry
            Q_ACTION_CAST(&on_i), // initial tran.
            Q_ACTION_CAST(0) // zero terminator
        }
    };
    // ${SMs::Calc::SM::initial}
    BSP_clear();
    (void)e; // unused parameter
    return QM_TRAN_INIT(&tatbl_);
}
//${SMs::Calc::SM::on} .......................................................
QP::QMState const Calc::on_s = {
    static_cast<QP::QMState const *>(0), // superstate (top)
    Q_STATE_CAST(&Calc::on),
    Q_ACTION_CAST(&Calc::on_e),
    Q_ACTION_CAST(&Calc::on_x),
    Q_ACTION_CAST(&Calc::on_i)
};
// ${SMs::Calc::SM::on}
QP::QState Calc::on_e(Calc * const me) {
    BSP_message("on-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&on_s);
}
// ${SMs::Calc::SM::on}
QP::QState Calc::on_x(Calc * const me) {
    BSP_message("on-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&on_s);
}
// ${SMs::Calc::SM::on::initial}
QP::QState Calc::on_i(Calc * const me) {
    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[3];
    } const tatbl_ = { // transition-action table
        &ready_s, // target state
        {
            Q_ACTION_CAST(&ready_e), // entry
            Q_ACTION_CAST(&ready_i), // initial tran.
            Q_ACTION_CAST(0) // zero terminator
        }
    };
    // ${SMs::Calc::SM::on::initial}
    BSP_message("on-INIT;");
    return QM_TRAN_INIT(&tatbl_);
}
// ${SMs::Calc::SM::on}
QP::QState Calc::on(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::C}
        case C_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &on_s, // target state
                {
                    Q_ACTION_CAST(&on_x), // exit
                    Q_ACTION_CAST(&on_e), // entry
                    Q_ACTION_CAST(&on_i), // initial tran.
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            BSP_clear();
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::OFF}
        case OFF_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &final_s, // target state
                {
                    Q_ACTION_CAST(&on_x), // exit
                    Q_ACTION_CAST(&final_e), // entry
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${SMs::Calc::SM::on::ready} ................................................
QP::QMState const Calc::ready_s = {
    &Calc::on_s, // superstate
    Q_STATE_CAST(&Calc::ready),
    Q_ACTION_CAST(&Calc::ready_e),
    Q_ACTION_CAST(&Calc::ready_x),
    Q_ACTION_CAST(&Calc::ready_i)
};
// ${SMs::Calc::SM::on::ready}
QP::QState Calc::ready_e(Calc * const me) {
    BSP_message("ready-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&ready_s);
}
// ${SMs::Calc::SM::on::ready}
QP::QState Calc::ready_x(Calc * const me) {
    BSP_message("ready-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&ready_s);
}
// ${SMs::Calc::SM::on::ready::initial}
QP::QState Calc::ready_i(Calc * const me) {
    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[2];
    } const tatbl_ = { // transition-action table
        &begin_s, // target state
        {
            Q_ACTION_CAST(&begin_e), // entry
            Q_ACTION_CAST(0) // zero terminator
        }
    };
    // ${SMs::Calc::SM::on::ready::initial}
    BSP_message("ready-INIT;");
    return QM_TRAN_INIT(&tatbl_);
}
// ${SMs::Calc::SM::on::ready}
QP::QState Calc::ready(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::ready::DIGIT_0}
        case DIGIT_0_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &operand1_s.super, // target state
                {
                    Q_ACTION_CAST(&ready_x), // exit
                    Q_ACTION_CAST(&operand1_e), // entry
                    Q_ACTION_CAST(&operand_i), // initial tran.
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            BSP_clear();
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::ready::DIGIT_1_9}
        case DIGIT_1_9_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &operand1_s.super, // target state
                {
                    Q_ACTION_CAST(&ready_x), // exit
                    Q_ACTION_CAST(&operand1_e), // entry
                    Q_ACTION_CAST(&SM_operand::intgr_ep), // EP
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            BSP_clear();
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::ready::POINT}
        case POINT_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &operand1_s.super, // target state
                {
                    Q_ACTION_CAST(&ready_x), // exit
                    Q_ACTION_CAST(&operand1_e), // entry
                    Q_ACTION_CAST(&SM_operand::frac_ep), // EP
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            BSP_clear();
            BSP_insert((int)'0');
            BSP_insert((int)'.');
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::ready::OPER}
        case OPER_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &opEntered_s, // target state
                {
                    Q_ACTION_CAST(&ready_x), // exit
                    Q_ACTION_CAST(&opEntered_e), // entry
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            me->m_op1  = BSP_get_value();
            me->m_oper = Q_EVT_CAST(CalcEvt)->key_code;
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${SMs::Calc::SM::on::ready::result} ........................................
QP::QMState const Calc::result_s = {
    &Calc::ready_s, // superstate
    Q_STATE_CAST(&Calc::result),
    Q_ACTION_CAST(&Calc::result_e),
    Q_ACTION_CAST(&Calc::result_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::ready::result}
QP::QState Calc::result_e(Calc * const me) {
    BSP_message("result-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&result_s);
}
// ${SMs::Calc::SM::on::ready::result}
QP::QState Calc::result_x(Calc * const me) {
    BSP_message("result-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&result_s);
}
// ${SMs::Calc::SM::on::ready::result}
QP::QState Calc::result(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}
//${SMs::Calc::SM::on::ready::begin} .........................................
QP::QMState const Calc::begin_s = {
    &Calc::ready_s, // superstate
    Q_STATE_CAST(&Calc::begin),
    Q_ACTION_CAST(&Calc::begin_e),
    Q_ACTION_CAST(&Calc::begin_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::ready::begin}
QP::QState Calc::begin_e(Calc * const me) {
    BSP_message("begin-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&begin_s);
}
// ${SMs::Calc::SM::on::ready::begin}
QP::QState Calc::begin_x(Calc * const me) {
    BSP_message("begin-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&begin_s);
}
// ${SMs::Calc::SM::on::ready::begin}
QP::QState Calc::begin(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::ready::begin::OPER}
        case OPER_SIG: {
            // ${SMs::Calc::SM::on::ready::begin::OPER::[e->key=='-']}
            if (Q_EVT_CAST(CalcEvt)->key_code == KEY_MINUS) {
                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[5];
                } const tatbl_ = { // transition-action table
                    &operand1_s.super, // target state
                    {
                        Q_ACTION_CAST(&begin_x), // exit
                        Q_ACTION_CAST(&ready_x), // exit
                        Q_ACTION_CAST(&operand1_e), // entry
                        Q_ACTION_CAST(&SM_operand::neg_ep), // EP
                        Q_ACTION_CAST(0) // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            // ${SMs::Calc::SM::on::ready::begin::OPER::[else]}
            else {
                status_ = QM_HANDLED();
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}
//${SMs::Calc::SM::on::operand1} .............................................
Calc::SM_operand const Calc::operand1_s = {
    {
        &Calc::on_s, // superstate
        Q_STATE_CAST(&Calc::operand1),
        Q_ACTION_CAST(&Calc::operand1_e),
        Q_ACTION_CAST(0), // no exit action
        Q_ACTION_CAST(0)  // no intitial tran.
    }
    ,Q_ACTION_CAST(&Calc::operand1_ce)
};
// ${SMs::Calc::SM::on::operand1}
QP::QState Calc::operand1_e(Calc * const me) {
    me->sub_operand = &operand1_s; // attach submachine
    return operand_e(me); // enter submachine
}
// ${SMs::Calc::SM::on::operand1}
QP::QState Calc::operand1_ce(Calc * const me) {
    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[3];
    } const tatbl_ = { // transition-action table
        &ready_s, // target state
        {
            Q_ACTION_CAST(&ready_e), // entry
            Q_ACTION_CAST(&ready_i), // initial tran.
            Q_ACTION_CAST(0) // zero terminator
        }
    };
    BSP_message("operand1-XP:ce;");
    return QM_TRAN(&tatbl_);
}
// ${SMs::Calc::SM::on::operand1}
QP::QState Calc::operand1(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::operand1::OPER}
        case OPER_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[2];
            } const tatbl_ = { // transition-action table
                &opEntered_s, // target state
                {
                    Q_ACTION_CAST(&opEntered_e), // entry
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            me->m_op1  = BSP_get_value();
            me->m_oper = Q_EVT_CAST(CalcEvt)->key_code;
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::operand1::EQUALS}
        case EQUALS_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &result_s, // target state
                {
                    Q_ACTION_CAST(&ready_e), // entry
                    Q_ACTION_CAST(&result_e), // entry
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${SMs::Calc::SM::on::opEntered} ............................................
QP::QMState const Calc::opEntered_s = {
    &Calc::on_s, // superstate
    Q_STATE_CAST(&Calc::opEntered),
    Q_ACTION_CAST(&Calc::opEntered_e),
    Q_ACTION_CAST(&Calc::opEntered_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::opEntered}
QP::QState Calc::opEntered_e(Calc * const me) {
    BSP_message("opEntered-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&opEntered_s);
}
// ${SMs::Calc::SM::on::opEntered}
QP::QState Calc::opEntered_x(Calc * const me) {
    BSP_message("opEntered-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&opEntered_s);
}
// ${SMs::Calc::SM::on::opEntered}
QP::QState Calc::opEntered(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::opEntered::DIGIT_0}
        case DIGIT_0_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &operand2_s.super, // target state
                {
                    Q_ACTION_CAST(&opEntered_x), // exit
                    Q_ACTION_CAST(&operand2_e), // entry
                    Q_ACTION_CAST(&SM_operand::zero_ep), // EP
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            BSP_clear();
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::opEntered::DIGIT_1_9}
        case DIGIT_1_9_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &operand2_s.super, // target state
                {
                    Q_ACTION_CAST(&opEntered_x), // exit
                    Q_ACTION_CAST(&operand2_e), // entry
                    Q_ACTION_CAST(&SM_operand::intgr_ep), // EP
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            BSP_clear();
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::opEntered::POINT}
        case POINT_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &operand2_s.super, // target state
                {
                    Q_ACTION_CAST(&opEntered_x), // exit
                    Q_ACTION_CAST(&operand2_e), // entry
                    Q_ACTION_CAST(&SM_operand::frac_ep), // EP
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            BSP_clear();
            BSP_insert((int)'0');
            BSP_insert((int)'.');
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::opEntered::OPER}
        case OPER_SIG: {
            // ${SMs::Calc::SM::on::opEntered::OPER::[e->key=='-']}
            if (Q_EVT_CAST(CalcEvt)->key_code == KEY_MINUS) {
                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[4];
                } const tatbl_ = { // transition-action table
                    &operand2_s.super, // target state
                    {
                        Q_ACTION_CAST(&opEntered_x), // exit
                        Q_ACTION_CAST(&operand2_e), // entry
                        Q_ACTION_CAST(&SM_operand::neg_ep), // EP
                        Q_ACTION_CAST(0) // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            // ${SMs::Calc::SM::on::opEntered::OPER::[else]}
            else {
                status_ = QM_HANDLED();
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}
//${SMs::Calc::SM::on::error} ................................................
QP::QMState const Calc::error_s = {
    &Calc::on_s, // superstate
    Q_STATE_CAST(&Calc::error),
    Q_ACTION_CAST(&Calc::error_e),
    Q_ACTION_CAST(&Calc::error_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::error}
QP::QState Calc::error_e(Calc * const me) {
    BSP_message("error-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&error_s);
}
// ${SMs::Calc::SM::on::error}
QP::QState Calc::error_x(Calc * const me) {
    BSP_message("error-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&error_s);
}
// ${SMs::Calc::SM::on::error}
QP::QState Calc::error(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}
//${SMs::Calc::SM::on::operand2} .............................................
Calc::SM_operand const Calc::operand2_s = {
    {
        &Calc::on_s, // superstate
        Q_STATE_CAST(&Calc::operand2),
        Q_ACTION_CAST(&Calc::operand2_e),
        Q_ACTION_CAST(0), // no exit action
        Q_ACTION_CAST(0)  // no intitial tran.
    }
    ,Q_ACTION_CAST(&Calc::operand2_ce)
};
// ${SMs::Calc::SM::on::operand2}
QP::QState Calc::operand2_e(Calc * const me) {
    me->sub_operand = &operand2_s; // attach submachine
    return operand_e(me); // enter submachine
}
// ${SMs::Calc::SM::on::operand2}
QP::QState Calc::operand2_ce(Calc * const me) {
    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[2];
    } const tatbl_ = { // transition-action table
        &opEntered_s, // target state
        {
            Q_ACTION_CAST(&opEntered_e), // entry
            Q_ACTION_CAST(0) // zero terminator
        }
    };
    BSP_message("operand2-XP:ce;");
    return QM_TRAN(&tatbl_);
}
// ${SMs::Calc::SM::on::operand2}
QP::QState Calc::operand2(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::operand2::OPER}
        case OPER_SIG: {
            // ${SMs::Calc::SM::on::operand2::OPER::[BSP_eval()]}
            if (BSP_eval(me->m_op1, me->m_oper, BSP_get_value())) {
                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[2];
                } const tatbl_ = { // transition-action table
                    &opEntered_s, // target state
                    {
                        Q_ACTION_CAST(&opEntered_e), // entry
                        Q_ACTION_CAST(0) // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            // ${SMs::Calc::SM::on::operand2::OPER::[else]}
            else {
                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[2];
                } const tatbl_ = { // transition-action table
                    &error_s, // target state
                    {
                        Q_ACTION_CAST(&error_e), // entry
                        Q_ACTION_CAST(0) // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        // ${SMs::Calc::SM::on::operand2::EQUALS}
        case EQUALS_SIG: {
            // ${SMs::Calc::SM::on::operand2::EQUALS::[BSP_eval()]}
            if (BSP_eval(me->m_op1, me->m_oper, BSP_get_value())) {
                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[3];
                } const tatbl_ = { // transition-action table
                    &result_s, // target state
                    {
                        Q_ACTION_CAST(&ready_e), // entry
                        Q_ACTION_CAST(&result_e), // entry
                        Q_ACTION_CAST(0) // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            // ${SMs::Calc::SM::on::operand2::EQUALS::[else]}
            else {
                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[2];
                } const tatbl_ = { // transition-action table
                    &error_s, // target state
                    {
                        Q_ACTION_CAST(&error_e), // entry
                        Q_ACTION_CAST(0) // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${SMs::Calc::SM::final} ....................................................
QP::QMState const Calc::final_s = {
    static_cast<QP::QMState const *>(0), // superstate (top)
    Q_STATE_CAST(&Calc::final),
    Q_ACTION_CAST(&Calc::final_e),
    Q_ACTION_CAST(0), // no exit action
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::final}
QP::QState Calc::final_e(Calc * const me) {
    BSP_message("final-ENTRY;");
    BSP_exit();
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&final_s);
}
// ${SMs::Calc::SM::final}
QP::QState Calc::final(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}
//${SMs::Calc::SM::operand} ..................................................
// ${SMs::Calc::SM::operand}
QP::QMState const Calc::operand_s = {
    static_cast<QP::QMState const *>(0), // superstate unused
    Q_STATE_CAST(&Calc::operand),
    Q_ACTION_CAST(&Calc::operand_e),
    Q_ACTION_CAST(&Calc::operand_x),
    Q_ACTION_CAST(&Calc::operand_i)
};
// ${SMs::Calc::SM::operand}
QP::QState Calc::operand_e(Calc * const me) {
    BSP_message("operand-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&operand_s);
}
// ${SMs::Calc::SM::operand}
QP::QState Calc::operand_x(Calc * const me) {
    BSP_message("operand-EXIT;");
    return QM_SM_EXIT(&me->sub_operand->super);
}
// ${SMs::Calc::SM::operand::initial}
QP::QState Calc::operand_i(Calc * const me) {
    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[2];
    } const tatbl_ = { // transition-action table
        &SM_operand::zero_s, // target state
        {
            Q_ACTION_CAST(&SM_operand::zero_e), // entry
            Q_ACTION_CAST(0) // zero terminator
        }
    };
    // ${SMs::Calc::SM::operand::initial}
    BSP_message("operand-INIT;");
    return QM_TRAN_INIT(&tatbl_);
}
// ${SMs::Calc::SM::operand}
QP::QState Calc::operand(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::operand::CE}
        case CE_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[2];
            } const tatbl_ = { // transition-action table
                &operand_s, // target state
                {
                    Q_ACTION_CAST(&operand_x), // exit
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            BSP_message("operand::CE;");
            BSP_clear();
            status_ = QM_TRAN_XP(me->sub_operand->ce, &tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER_SUB(&me->sub_operand->super);
            break;
        }
    }
    return status_;
}
// ${SMs::Calc::SM::operand::zero}
QP::QState Calc::SM_operand::zero_ep(Calc * const me) {
    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[2];
    } const tatbl_ = { // transition-action table
        &SM_operand::zero_s, // target state
        {
            Q_ACTION_CAST(&SM_operand::zero_e), // entry
            Q_ACTION_CAST(0) // zero terminator
        }
    };
    BSP_message("operand::zero-EP;");
    return QM_TRAN_EP(&tatbl_);
}
// ${SMs::Calc::SM::operand::intgr}
QP::QState Calc::SM_operand::intgr_ep(Calc * const me) {
    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[2];
    } const tatbl_ = { // transition-action table
        &SM_operand::intgr_s, // target state
        {
            Q_ACTION_CAST(&SM_operand::intgr_e), // entry
            Q_ACTION_CAST(0) // zero terminator
        }
    };
    BSP_message("operand::intgr-EP;");
    return QM_TRAN_EP(&tatbl_);
}
// ${SMs::Calc::SM::operand::frac}
QP::QState Calc::SM_operand::frac_ep(Calc * const me) {
    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[2];
    } const tatbl_ = { // transition-action table
        &SM_operand::frac_s, // target state
        {
            Q_ACTION_CAST(&SM_operand::frac_e), // entry
            Q_ACTION_CAST(0) // zero terminator
        }
    };
    BSP_message("operand::frac-EP;");
    return QM_TRAN_EP(&tatbl_);
}
// ${SMs::Calc::SM::operand::neg}
QP::QState Calc::SM_operand::neg_ep(Calc * const me) {
    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[2];
    } const tatbl_ = { // transition-action table
        &SM_operand::neg_s, // target state
        {
            Q_ACTION_CAST(&SM_operand::neg_e), // entry
            Q_ACTION_CAST(0) // zero terminator
        }
    };
    BSP_message("operand::neg-EP;");
    return QM_TRAN_EP(&tatbl_);
}
//${SMs::Calc::SM::operand::zero} ............................................
QP::QMState const Calc::SM_operand::zero_s = {
    &Calc::operand_s, // superstate
    Q_STATE_CAST(&Calc::SM_operand::zero),
    Q_ACTION_CAST(&Calc::SM_operand::zero_e),
    Q_ACTION_CAST(&Calc::SM_operand::zero_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::operand::zero}
QP::QState Calc::SM_operand::zero_e(Calc * const me) {
    BSP_message("operand::zero-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&SM_operand::zero_s);
}
// ${SMs::Calc::SM::operand::zero}
QP::QState Calc::SM_operand::zero_x(Calc * const me) {
    BSP_message("operand::zero-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&SM_operand::zero_s);
}
// ${SMs::Calc::SM::operand::zero}
QP::QState Calc::SM_operand::zero(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::operand::zero::DIGIT_0}
        case DIGIT_0_SIG: {
            ;
            status_ = QM_HANDLED();
            break;
        }
        // ${SMs::Calc::SM::operand::zero::DIGIT_1_9}
        case DIGIT_1_9_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &SM_operand::intgr_s, // target state
                {
                    Q_ACTION_CAST(&SM_operand::zero_x), // exit
                    Q_ACTION_CAST(&SM_operand::intgr_e), // entry
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::operand::zero::POINT}
        case POINT_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &SM_operand::frac_s, // target state
                {
                    Q_ACTION_CAST(&SM_operand::zero_x), // exit
                    Q_ACTION_CAST(&SM_operand::frac_e), // entry
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            BSP_insert((int)'0');
            BSP_insert((int)'.');
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${SMs::Calc::SM::operand::intgr} ...........................................
QP::QMState const Calc::SM_operand::intgr_s = {
    &Calc::operand_s, // superstate
    Q_STATE_CAST(&Calc::SM_operand::intgr),
    Q_ACTION_CAST(&Calc::SM_operand::intgr_e),
    Q_ACTION_CAST(&Calc::SM_operand::intgr_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::operand::intgr}
QP::QState Calc::SM_operand::intgr_e(Calc * const me) {
    BSP_message("operand::intgr-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&SM_operand::intgr_s);
}
// ${SMs::Calc::SM::operand::intgr}
QP::QState Calc::SM_operand::intgr_x(Calc * const me) {
    BSP_message("operand::intgr-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&SM_operand::intgr_s);
}
// ${SMs::Calc::SM::operand::intgr}
QP::QState Calc::SM_operand::intgr(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::operand::intgr::POINT}
        case POINT_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &SM_operand::frac_s, // target state
                {
                    Q_ACTION_CAST(&SM_operand::intgr_x), // exit
                    Q_ACTION_CAST(&SM_operand::frac_e), // entry
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            BSP_insert((int)'.');
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::operand::intgr::DIGIT_0, DIGIT_1_9}
        case DIGIT_0_SIG: // intentionally fall through
        case DIGIT_1_9_SIG: {
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_HANDLED();
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}
//${SMs::Calc::SM::operand::frac} ............................................
QP::QMState const Calc::SM_operand::frac_s = {
    &Calc::operand_s, // superstate
    Q_STATE_CAST(&Calc::SM_operand::frac),
    Q_ACTION_CAST(&Calc::SM_operand::frac_e),
    Q_ACTION_CAST(&Calc::SM_operand::frac_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::operand::frac}
QP::QState Calc::SM_operand::frac_e(Calc * const me) {
    BSP_message("operand::frac-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&SM_operand::frac_s);
}
// ${SMs::Calc::SM::operand::frac}
QP::QState Calc::SM_operand::frac_x(Calc * const me) {
    BSP_message("operand::frac-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&SM_operand::frac_s);
}
// ${SMs::Calc::SM::operand::frac}
QP::QState Calc::SM_operand::frac(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::operand::frac::POINT}
        case POINT_SIG: {
            ;
            status_ = QM_HANDLED();
            break;
        }
        // ${SMs::Calc::SM::operand::frac::DIGIT_0, DIGIT_1_9}
        case DIGIT_0_SIG: // intentionally fall through
        case DIGIT_1_9_SIG: {
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_HANDLED();
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}
//${SMs::Calc::SM::operand::neg} .............................................
QP::QMState const Calc::SM_operand::neg_s = {
    &Calc::operand_s, // superstate
    Q_STATE_CAST(&Calc::SM_operand::neg),
    Q_ACTION_CAST(&Calc::SM_operand::neg_e),
    Q_ACTION_CAST(&Calc::SM_operand::neg_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::operand::neg}
QP::QState Calc::SM_operand::neg_e(Calc * const me) {
    BSP_message("operand::neg-ENTRY;");
    BSP_negate();
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&SM_operand::neg_s);
}
// ${SMs::Calc::SM::operand::neg}
QP::QState Calc::SM_operand::neg_x(Calc * const me) {
    BSP_message("operand::neg-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&SM_operand::neg_s);
}
// ${SMs::Calc::SM::operand::neg}
QP::QState Calc::SM_operand::neg(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::operand::neg::DIGIT_0}
        case DIGIT_0_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &SM_operand::zero_s, // target state
                {
                    Q_ACTION_CAST(&SM_operand::neg_x), // exit
                    Q_ACTION_CAST(&SM_operand::zero_e), // entry
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::operand::neg::DIGIT_1_9}
        case DIGIT_1_9_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &SM_operand::intgr_s, // target state
                {
                    Q_ACTION_CAST(&SM_operand::neg_x), // exit
                    Q_ACTION_CAST(&SM_operand::intgr_e), // entry
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::operand::neg::POINT}
        case POINT_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &SM_operand::frac_s, // target state
                {
                    Q_ACTION_CAST(&SM_operand::neg_x), // exit
                    Q_ACTION_CAST(&SM_operand::frac_e), // entry
                    Q_ACTION_CAST(0) // zero terminator
                }
            };
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::operand::neg::OPER}
        case OPER_SIG: {
            // ${SMs::Calc::SM::operand::neg::OPER::[e->key=='-']}
            if (Q_EVT_CAST(CalcEvt)->key_code == KEY_MINUS) {
                ;
                status_ = QM_HANDLED();
            }
            // ${SMs::Calc::SM::operand::neg::OPER::[else]}
            else {
                status_ = QM_HANDLED();
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}

